<!DOCTYPE html>
<html lang="en">

<head>
    <title>Oculus example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
        }

    </style>
</head>

<body>
    <script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>


    <script type="module">
        import * as THREE from '//cdn.rawgit.com/mrdoob/three.js/master/build/three.module.js';
			//import { BoxLineGeometry } from './node_modules/three/examples/jsm/geometries/BoxLineGeometry.js';
			import { VRButton } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/webxr/VRButton.js';
            import { TubePainter } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/misc/TubePainter.js';


var camera, scene, renderer;
var geometry, material, mesh;
var collectionBrainCoordinates = new THREE.Geometry();
var controller1, controller2;

var points;     
var selectionDirection = 0.0;

var cursor = new THREE.Vector3();

init();
animate();

      
startLoadingData();
var nodes = new Array();
    
      
var radius = 0.8;
var geometry = new THREE.IcosahedronBufferGeometry( radius, 2 );

var object1;
var object2;//new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
    
function startLoadingData()
{
    var httpRequest = new XMLHttpRequest();
    httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === 4){
            // everything is good, the response is received
            if ((httpRequest.status == 200) || (httpRequest.status == 0)){
//                console.log("Done loading edges coordinates");
                var buffer = httpRequest.response;
                 var dataview = new DataView(buffer);
                 var ints = new Float32Array(buffer.byteLength / 4);
                 for (var i = 0; i < ints.length; i++) {
                     ints[i] = dataview.getFloat32(i * 4);
                 }
//                console.log(ints);


                for(var row=0; row < ints.length; row=row+4) {

                    nodes[row/4] = new Array();
                    nodes[row/4][0] = ints[row] //x
                    nodes[row/4][1] = ints[row+1] //y
                    nodes[row/4][2] = ints[row+2] //z
                    nodes[row/4][3] = ints[row+3] //i
                }
//                console.log(nodes)


                for (var row = 0; row < nodes.length; row++) {
                    var particle = new THREE.Vector3(nodes[row][0], nodes[row][1], nodes[row][2]);
                    collectionBrainCoordinates.vertices.push(particle);
                }
//              console.log(collectionBrainCoordinates);
                //scene.add(collectionBrainCoordinates);


                var particles = nodes.length;
            var geometry = new THREE.BufferGeometry();
            var positions = [];
            var colors = [];
            var color = new THREE.Color();
            var n = 100;
            var n2 = n / 2; // particles spread in the cube
            for ( var i = 0; i < particles; i ++ ) {
                // positions
                var x = nodes[i][0];
                var y = nodes[i][1];
                var z = nodes[i][2];
                positions.push( x, y, z );
                // colors
                var vx = ( x / n ) + 0.5;
                var vy = ( y / n ) + 0.5;
                var vz = ( z / n ) + 0.5;
                color.setRGB( vx, vy, vz );
                colors.push( color.r, color.g, color.b );
            }
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
            geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
            geometry.computeBoundingSphere();
            //
            var material = new THREE.PointsMaterial( { size: 0.01, vertexColors: THREE.VertexColors } );
            points = new THREE.Points( geometry, material );
            scene.add( points );

        }}}
        // Send the request
    httpRequest.open("GET", 'cars.npy', true);
    httpRequest.responseType = "arraybuffer";

    httpRequest.send();
    }
      
 function onSelectStart(){
    selectionDirection = 1.0;
     
 }
 function onSelectEnd(){
    selectionDirection = 0.0;
 }
        
        function onSelectStartRight(){
    selectionDirection = -1.0;
     
 }
 function onSelectEndRight(){
    selectionDirection = 0.0;
 }
function init() {
    camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 3500 );
    camera.position.z = 2750;
    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x050505 );
    scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );
    //

    //
    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.xr.enabled = true;

    controller1 = renderer.xr.getController( 0 );
    controller1.addEventListener( 'selectstart', onSelectStart );
    controller1.addEventListener( 'abuttondown', onSelectStart );
    controller1.addEventListener( 'bbuttondown', onSelectStart );
    controller1.addEventListener( 'squeezestart', onSelectStart );
    controller1.addEventListener( 'selectend', onSelectEnd );
    
    var painter1 = new TubePainter();
    var painter2 = new TubePainter();
    
    
//    controller1.userData.painter = painter1;
    
//    scene.add( painter1.mesh );
    scene.add( controller1 );

    controller2 = renderer.xr.getController( 1 );
//    controller2.userData.painter = painter2;

    
    
//    scene.add( painter2.mesh );
    scene.add( controller2 );
    controller2.addEventListener( 'selectstart', onSelectStartRight );
    controller2.addEventListener( 'selectend', onSelectEndRight );
    
    document.body.appendChild( renderer.domElement );


    document.body.appendChild( VRButton.createButton( renderer ) );
    var light = new THREE.PointLight( 0xffffff, 1, 100 );
    light.position.set( 0, 0, 0 );
    scene.add( light );
    
//    object1 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
//    object2 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
//    
//    object1.position.x=Math.random() * 20 - 2;
//    object1.position.y=Math.random() * 20;
//    object1.position.z=Math.random() * 20 - 2; 
//    
//    object2.position.x=Math.random() * 20 - 2;
//    object2.position.y=Math.random() * 20;
//    object2.position.z=Math.random() * 20 - 2; 
//    controller1.userData.painter = object1;
// controller2.userData.painter = object2;
    
//    scene.add(painter1);// scene.add(painter2);
//    scene.add(object1);// scene.add(object2);
//    
//    var radius = 0.8;
//    var geometry = new THREE.IcosahedronBufferGeometry( radius, 2 );
//    for ( var i = 0; i < 200; i ++ ) { 
//        var object=new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ); 
//        object.position.x=Math.random() * 20 - 2; 
//        object.position.y=Math.random() * 20; 
//        object.position.z=Math.random() * 20 - 2; 
//        object.userData.velocity=new THREE.Vector3(); 
//        object.userData.velocity.x=Math.random() * 0.01 - 0.005; 
//        object.userData.velocity.y=Math.random() * 0.01 - 0.005; 
//        object.userData.velocity.z=Math.random() * 0.01 - 0.005; 
//        scene.add( object ); 
//    }
}
        
        
function handleController1( controller ) {
    var radius = 0.02;
    var geometry = new THREE.IcosahedronBufferGeometry( radius, 2 );

    var object=new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ); 
    object.position.x=Math.random() * 0.2 + controller.position.x; 
    object.position.y=Math.random() * 0.2 + controller.position.y; 
    object.position.z=Math.random() * 0.2 + controller.position.z; 

    scene.add( object ); 

}

function handleController2( controller ) {
    object2.position.set(controller.position);
}
function animate() {
    renderer.setAnimationLoop( function () {
        
        handleController1( controller1 );
// handleController2( controller2 );
        
        if (selectionDirection != 0.0){
            console.log(controller1);
            let xrCamera = renderer.xr.getCamera(camera)
            let e = xrCamera.matrixWorld.elements
            let direction = new THREE.Vector3(selectionDirection*e[8], selectionDirection*e[9], selectionDirection*e[10]).normalize()
            direction.multiplyScalar(-0.05);
            
            points.position.add(direction);
            
        }

	renderer.render( scene, camera );

} );
}


  </script>
</body>

</html>
